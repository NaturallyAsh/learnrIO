---
title: "Tidy Data"
---

### Introduction
As IO Psychologists, we often deal with a lot of data, be it employee performance metrics, survey responses, or recruitment data. One of the key challenges we face is ensuring that this data is well-organized and easy to analyze. Enter the concept of "Tidy Data" - a term coined by Hadley Wickham, the creator of many of the tools in the tidyverse package in R.

According to Wickham, "Tidy datasets are all alike, but every messy dataset is messy in its own way." The idea is to organize your data in a consistent way that makes it easier to work with and analyze. In essence, tidy data is about structuring datasets to facilitate analysis.  

### Tidy Data Principles

Tidy data follows three fundamental rules:  

- Each variable must have its own column.  
- Each observation must have its own row.  
- Each value must have its own cell.  


[Placeholder for an image illustrating tidy data]


The advantages of tidy data are twofold. Firstly, having a consistent data structure makes it easier to learn the tools that work with it. Secondly, placing variables in columns allows R's vectorized nature to shine, making data transformation feel natural. By maintaining tidy datasets, you can streamline your data analysis process, make it easier to handle missing values, and enhance the readability and organization of your data.  

Let's consider an example where we have data on employee satisfaction, performance, and tenure. The tidy version of this data would look something like this:  

| Employee ID | Satisfaction | Performance | Tenure |
|---|---|---|---|
| 1 | 7 | 8 | 2 |
| 2 | 8 | 7 | 3 |
| 3 | 9 | 9 | 5 |
| 4 | 6 | 5 | 1 | 

In this example, each variable (Satisfaction, Performance, Tenure) has its own column, each observation (each employee) has its own row, and each value has its own cell.  


### Pivoting Data

In practice, you'll often encounter data that is not tidy. For instance, a variable might be spread across multiple columns, or one observation might be scattered across multiple rows. To handle such scenarios, `tidyr`, a core tidyverse package for working with messy data, provides two pivotal functions: `pivot_longer()` and `pivot_wider()`.  

Let's discuss each one in detail.  

### `pivot_longer()` 

is used to make "wide" data longer. In other words, it takes multiple columns and combines them into key-value pairs, duplicating all other columns as needed.  

```{r, eval=FALSE}
tidy_survey_data <- survey_data |> pivot_longer(
  cols = starts_with("Question"),
  names_to = "Question",
  values_to = "Answer"
)
```

`pivot_wider()` does the opposite. It makes "long" data wider, spreading out a key-value pair across multiple columns.  

```{r, eval=FALSE}
wide_survey_data <- tidy_survey_data |> pivot_wider(
  names_from = "Question",
  values_from = "Answer"
)
```


### Separate and unite
At times, we might have a single column containing two variables. In such a case, we can use the `separate()` function to split that column into two. For example, imagine a column 'Question_Answer' in our survey data that combines the question number and the answer.  

```{r, eval=FALSE}
tidy_survey_data <- untidy_survey_data |> separate(
  Question_Answer, 
  into = c("Question", "Answer"), 
  sep = "_"
)
```

Conversely, we might need to combine two columns into one. The unite() function does this.  
```{r, eval=FALSE}
untidy_survey_data <- too_tidy_survey_data |> unite(
  "Question_Answer", 
  Question, Answer, 
  sep = "_"
)
```


### The Pipe Operator **(`|>`)**  
I bet you are wondering what that strange `|>` symbol is that we used in the above section. This symbol is a very useful method for creating tidy data, and it called the pipe operator (`|>`). This operator allows you to pipe your data from one function to the next. It's used to make your code cleaner and easier to read. The pipe operator fundamentally transforms the way you use R for data manipulation, leading to a tidier, more readable, and maintainable code.  

You may be unfamiliar with some of the functions used in the following code examples (such as `filter()`). Don't worry! We will cover them in detail in the next lesson: Transforming Data!  

Consider an example where you have a dataset of employees, and you want to filter out the HR department, select the age and salary columns, and calculate the average salary:  


```{r, eval=FALSE}
employees_data |> 
  filter(department == "HR") |> 
  select(age, salary) |> 
  summarise(avg_salary = mean(salary, na.rm = TRUE))
```

This code reads from left to right in a logical order, making it easier to follow.  

### The Benefit of Using Piping in Tidyverse

The introduction of the pipe operator has transformed the way we can write and read R code. Let's consider the same task as above, but without using the pipe operator:  

```{r, eval=FALSE}
avg_salary <- summarise(select(filter(employees_data, department == "HR"), age, salary), avg_salary = mean(salary, na.rm = TRUE))
```

Without piping, this code becomes much harder to read. Functions are nested within one another, and the code reads from inside-out, rather than from left to right. It's also much more challenging to add or remove steps from the analysis.  

On the other hand, the pipe operator allows us to follow the logic of our data transformation step by step. It facilitates a style of programming that emphasizes clear, readable code, and promotes the chaining of functions, where the output of one function is the input to the next. Take another look at the piping of the `employees_data` to calculate the same `avg_salary`:  

```{r, eval=FALSE}
employees_data |> 
  filter(department == "HR") |> 
  select(age, salary) |> 
  summarise(avg_salary = mean(salary, na.rm = TRUE))
```

So much neater, right!? This is a powerful style, especially for data manipulation tasks.


### Your Turn

Time to apply what you've learned about tidying data! Here are three exercises for you to try using the survey_data, untidy_survey_data, and too_tidy_survey_data datasets.  

**Exercise 1:** Use `pivot_longer()` on the `survey_data` dataset to transform it into a long format where we have three distinct columns: 'Employee', 'Question', and 'Answer'.  

```{r}

```


**Exercise 2:** The `untidy_survey_data` dataset has a 'Question_Answer' column that combines the question number and the answer. Use the `separate()` function to split this column into two separate columns: 'Question' and 'Answer'.  

```{r}

```


**Exercise 3:** The `too_tidy_survey_data` dataset has separated 'Question' and 'Answer' columns. Use the `unite()` function to combine these into a single column named 'Question_Answer'.  

```{r}

```




Remember to inspect the results after each step to ensure that your transformations have worked as expected. **Keep up the good work!**
