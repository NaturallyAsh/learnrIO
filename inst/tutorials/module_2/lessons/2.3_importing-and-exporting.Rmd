---
title: "Importing and exporting data"
---
### Importing csv files
Data can come in various forms and from different sources. Two of the most common are csv (comma-separated values) and excel file types.  

The `readr` package is a part of the tidyverse. `readr` provides functions for importing flat files, a two-dimensional tabular structured file where a column represents one dimension and rows represent the other dimension.  

We can use `readr::read_csv()` to import csv flat files:  
```{r, eval=TRUE}
library(readr)
person_data <- read_csv(file = "https://raw.githubusercontent.com/davidcaughlin/R-Tutorial-Data-Files/master/PersData.csv") 

person_data |>
  head()
```

Using `head()` to view the first 6 rows of the imported data, you can see the column names along with the data types (i.e., `id` values are type **double**, `lastname` values are type **character**, etc.).  



### Importing Excel files  
You will often find encounter Excel data. We can use the `readxl` package to import xls and xlsx Excel file types.  
```{r, include=FALSE}
path_excel_data <- system.file("extdata", "PersData_Excel.xlsx", package = "learnrIO", mustWork = TRUE)
```

We can use the `readxl::read_excel()` function which reads xls or xlsx files.  
```{r}
readxl::read_excel(path = path_excel_data)
```

Running the above function with only the 'path' argument returns the first Excel sheet, in this case sheet "Year1". The dataset, however, contains two sheets. The `read_excel()` function provides options for fine-tuning Excel imports, such as importing a sheet other than the first or importing a column/row cell range.  

*Import the second sheet "Year2"*  
```{r}
sheet2 <- readxl::read_excel(
  path = path_excel_data,
  sheet = "Year2"
)
sheet2
```

*Import the first 3 rows from the `id`, `lastname`, and `firstname` columns from the first sheet "Year1"*  
```{r}
sheet1 <- readxl::read_excel(
  path = path_excel_data,
  range = "A1:C4"
)
sheet1
```

Type `?read_xlsx` to see additional examples.  



### Importing other file formats with `haven`  
For other common file formats like SPSS, Stata, and SAS, we can use the haven package.  

**Import SPSS file**  
```{r, include=FALSE}
path_sav_data <- system.file("extdata", "exam.sav", package = "learnrIO", mustWork = TRUE)
```

```{r}
haven::read_sav(path_sav_data) |> head()
```



### Exporting Data
You can easily export a tibble to csv, Excel, or other file formats such as SPSS.  

**Export to csv using `readr`**  
```{r, eval=FALSE}
readr::write_csv(person_data, "person_data.csv")
```

**Export to Excel using `writexl`**  
```{r, eval=FALSE}
writexl::write_xlsx(person_data, "person_data.xlsx")
```

**Export to SPSS using `haven`**  
```{r, eval=FALSE}
haven::write_sav(person_data, "person_data.sav")
```


### Working with Tibbles
A tibble, or tbl_df, is an enhanced version of a data frame. While it keeps what works well in data frames, it tweaks some parts to make data handling smoother. For example, it doesn’t convert strings to factors, it doesn’t adjust row names, and it allows for non-syntactic column names. Tibbles also have improved print methods that show only the first 10 rows and all columns that fit on the screen.  

#### Creating a Tibble
Creating a tibble is straightforward with the `tibble()` function. Let's create a tibble with employee data:  

```{r, eval=FALSE}
# Load the Tidyverse
library(tidyverse)

# Create a tibble
employee_tibble <- tibble(
  name = c("Alice", "Bob", "Charlie", "David", "Eve"),
  age = c(24, 30, 35, 42, 29),
  department = c("Sales", "HR", "IT", "Marketing", "Sales"),
  salary = c(50000, 55000, 60000, 65000, 70000)
)
```

#### Working with Tibbles
Working with tibbles is similar to working with data frames. You can use the `$` operator to extract a column:  

```{r, eval=FALSE}
# Extract the 'age' column
employee_ages <- employee_tibble$age
```

And the `filter()`, `select()`, `mutate()`, and `summarise()` functions from dplyr work the same way (we'll dive deeper into `dplyr` in the next lesson):  

```{r, eval=FALSE}
# Filter to get employees older than 30
older_employees <- filter(employee_tibble, age > 30)

# Select the 'name' and 'salary' columns
names_and_salaries <- select(employee_tibble, name, salary)

# Add a new 'salary_group' column
employee_tibble <- mutate(employee_tibble, salary_group = ifelse(salary > 60000, "High", "Low"))

# Get the average age of employees
average_age <- summarise(employee_tibble, avg_age = mean(age))

```



#### Subsetting Tibbles
Subsetting tibbles also works similarly to subsetting data frames. However, tibbles do not simplify to a vector when a single column is selected with `[[]]` or `[]`. Instead, a tibble is always returned:  

```{r, eval=FALSE}
# Subsetting with '[[]]'
one_column_tibble <- employee_tibble[["age"]]

# Subsetting with '[]'
another_column_tibble <- employee_tibble["age"]
```

You now have a basic understanding of tibbles, and why they're a crucial part of the Tidyverse. They're designed to handle common data frame pain points, resulting in a cleaner, more intuitive way of working with data in R.  

### Your Turn
Now that we've delved into the world of tibbles, it's time for you to put what you've learned into practice. Here are a couple of exercises for you to try. Remember, the key to mastering these concepts is regular practice!  

**Exercise 1: Creating a Tibble**  
Create a tibble named `project_teams` with the following data:  

- team_id: c(1, 2, 3, 4, 5)  
- project_name: c("Phoenix", "Hydra", "Kraken", "Pegasus", "Dragon")  
- team_lead: c("Sarah", "Joshua", "Nina", "Carlos", "Preeti")  
- project_budget: c(5000, 7500, 6000, 6500, 8000)  

```{r}

```


**Exercise 2: Manipulating and Subsetting a Tibble**  
Using the `project_teams` tibble you created in Exercise 1:  

- Add a new column named `budget_group` that categorizes the projects as 'Low Budget' if the project_budget is less than 7000 and 'High Budget' otherwise.  
- Subset the `project_teams` tibble to select only the 'team_lead' and 'budget_group' columns for 'High Budget' projects.  

```{r}

```

