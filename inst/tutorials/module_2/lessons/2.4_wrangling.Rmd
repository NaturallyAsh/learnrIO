---
title: "Data Wrangling"
---

One of the most crucial aspects of data analysis: data wrangling. Data wrangling is all about cleaning, structuring, and enriching raw data into a desired format for better decision making. We'll be using dplyr, a core package of the Tidyverse, to demonstrate the powerful capabilities of data wrangling.  

### What is dplyr? 
**dplyr** is a powerful R package that provides a set of tools for efficiently manipulating datasets in R. It offers a flexible set of verbs that allow you to perform common data manipulation tasks such as filtering, mutating (adding new variables), summarizing, and so on.  

**The Pipe Operator (`|>`)**  
Before we dive into dplyr, it's important to understand the pipe operator (`|>`). This operator allows you to pipe your data from one function to the next. It's used to make your code cleaner and easier to read.

Consider an example where you have a dataset of employees, and you want to filter out the HR department, select the age and salary columns, and calculate the average salary:  


```{r, eval=FALSE}
employee_data |> 
  filter(department == "HR") |> 
  select(age, salary) |> 
  summarise(avg_salary = mean(salary, na.rm = TRUE))
```

(ADD VS WITHOUT PIPE HERE; LESS NEAT)  


**Now, let's explore the key functions for data wrangling provided by dplyr.**  

### dplyr Functions 
Let's take a closer look at some of the core dplyr functions:  

**filter()**  
The `filter()` function lets you select rows in your data that meet certain criteria. It's like asking questions of your data. For instance, you might want to see only the data for employees in the "Sales" department. You'd do this by using:  
```{r, eval=FALSE}
sales_data <- employee_data |> filter(department == "Sales")
```

**select()**  
`select()` allows you to focus on specific columns (variables) in your dataset. For example, if you only want to work with the 'name', 'age', and 'salary' columns, you could use:  

```{r, eval=FALSE}
selected_data <- employee_data |> select(name, age, salary)
```

**mutate()**  
`mutate()` lets you add new variables to your dataset. These can be transformations of existing variables, or they could be entirely new variables you calculate based on existing variables. For instance, you might want to calculate a new salary after a 5% increase:  

```{r, eval=FALSE}
mutated_data <- employee_data |> mutate(salary_increase = salary * 1.05)
```

You can also use `mutate()` with the `across()` function to apply a transformation to multiple columns at once. Say we want to round all salary related columns:  

```{r, eval=FALSE}
rounded_data <- employee_data |> mutate(across(ends_with("salary"), round))
```


**arrange()**  
`arrange()` lets you reorder rows according to the values of particular columns. By default, it sorts in ascending order, but you can sort in descending order by using `desc()`. For example, to arrange employees by age:  

```{r, eval=FALSE}
arranged_data <- employee_data |> arrange(desc(age))
```


**group_by() and summarise()**  
`group_by()` and `summarise()` are a powerful combination. `group_by()` allows you to group your data based on the values in one or more columns, and `summarise()` allows you to calculate summary statistics for each group. For instance, you can calculate the average salary by department like this:  

```{r, eval=FALSE}
summary_data <- employee_data |> 
                group_by(department) |> 
                summarise(avg_salary = mean(salary, na.rm = TRUE))
```

**count()**  
`count()` is a convenient function that combines `group_by()` and `summarise()` to quickly count the total number of records within each group. For instance, to count the number of employees in each department:  

```{r, eval=FALSE}
count_data <- employee_data |> count(department)
```


**bind_rows() and bind_cols()**  
`bind_rows()` and `bind_cols()` are useful functions for combining two datasets. `bind_rows()` stacks two datasets on top of each other, while `bind_cols()` places them side by side:  

```{r, eval=FALSE}
# Assuming we have two similar datasets, employee_data1 and employee_data2
combined_data <- bind_rows(employee_data1, employee_data2)

# Assuming we have two datasets, employee_data and benefits_data, with the same number of rows
combined_data_cols <- bind_cols(employee_data, benefits_data)
```


**Changing column data types**  
Sometimes, we may need to change the data type of a column to perform certain operations. For instance, changing a character column to a numeric or vice versa. We can use `mutate()` with functions like `as.character()`, `as.numeric()`, `as.Date()`, etc. to change data types.  

```{r, eval=FALSE}
# Changing 'age' column from numeric to character
changed_data <- employee_data |> mutate(age = as.character(age))
```


**Joining Datasets**  
dplyr also provides several functions to join datasets based on common variables, including `inner_join()`, `left_join()`, `right_join()`, and `full_join()`. For example, if we have another dataset `department_data` with more information about each department, we could join it to our employee data:  

```{r, eval=FALSE}
joined_data <- employee_data |> inner_join(department_data, by = "department")
```



### Your Turn
Now it's your turn to put your newfound knowledge of dplyr into practice. Here are a couple of exercises to get you started.  

**Exercise 1:** Use the `mutate()` function to create a new column in `employee_data` called 'seniority' This column should categorize employees as "Junior" if their age is less than 35, "Mid-level" if their age is between 35 and 45 (inclusive), and "Senior" if their age is more than 45.  
  - Hint: You can use the `case_when()` function within `mutate()` to accomplish this. Type `?case_when` in your console to see the help documentation.  
  
**Exercise 2:** Combine `employee_data1` and `employee_data2` into a single dataset using `bind_rows()`. Then, use `group_by()` and `summarise()` to calculate the average salary for each department in the combined dataset.  

**Exercise 3:** Join `employee_data` and `department_data` on the 'department' column using `inner_join()`. Then, use `select()` to choose only the 'name', 'department', 'location', and 'salary' columns. Arrange the resulting dataset by 'department' and 'salary' in descending order.


**Keep practicing!** Remember, the more you code, the more comfortable you'll get with these concepts.
